DOM规范是运行在浏览器上的规范，比如navigator,只在dom上有，在node上没有；而ECMAScript规范，不仅在浏览器中可以使用，也可以在node.js中使用。


大家好，首先谢谢大家百忙之中来听我的分享。
今天分享的主题是关于前端对异步的一些处理。
今天的分享可能没有上一期那么具有趣味性，主要是分享一些学习es6的语法糖。所以给大家准备了一些糖果，下面请大家边吃糖边和我一起回顾这些语法糖吧。😊
之所以想做这个分享呢，是因为，在项目中，前后端分离的基础就是异步。js一直在完善对异步的一些处理方式，我也非常喜欢跟随着前端大牛的脚步，让自己的异步代码处理的越来越优雅。相信很多小伙伴已经尝试过es6新语法了，在后面的分享中，有理解有出入的地方，还请大家积极的反馈出来。
首先，咱们先回想一下异步的一些特点：
大家都知道，js是单线程的，如果没有回调和异步，可以说是没办法投入使用的。大家都知道从硬盘上读取文件是比较耗时的，所以js认为文件处理也是一个异步的过程，nodejs封装的fs模块，读文件和写文件都各有一个同步方法和一个异步方法。给大家演示一下读文件的两种方法（readStream.js），还有一种异步处理就是大家常用的网络请求了，我们一般用的$.ajax、axios、vue-resource这些是封装后的用户，简单的写了一下基本原理。

所谓"异步"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。

比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。

相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。
JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是"重新调用"。

怎么让自己的异步代码更加优雅呢，首先大家想到的应该是使用promise，这个构造函数是es2015纳入标准的。
promise有三种状态，当被new出来的时候属于pending状态，使用resolve则是fulfill状态，使用reject则是fail状态
promise就是一个承诺，在js中就是承诺过段时间会返回一个结果，而这个过段时间就指的是异步操作。promise本质上是一个有限状态机，状态机指的是根据特定的条件按照一定的顺序进行转换，而且过程不可逆。每个promise实例都有三种状态：pending、resolve、reject。在状态机中，需要某些条件才能将自己的状态触发。状态只有两种：从初始状态到成功：pending->resolve;从初始状态到失败：pending->reject。promise实例状态机状态的变化会触发promise原型上的then或catch方法的执行

这里我用定时器模拟了几个异步的过程，让大家可以直观的查看promise api的几种方法

async相当于是generator+promise+co，是es7的新语法，目前没有浏览器实现，所以需要用webpack+babel编译一下才可以运行。既然是Generator 函数的语法糖，所以我们先来回顾一下generator的语法吧。
Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行,
必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行


